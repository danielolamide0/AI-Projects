# -*- coding: utf-8 -*-
"""ML CW.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xufAMmC_yX4bP2sjG7WB8yAZiSGw41t4
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# %matplotlib inline

ufc_df = pd.read_csv('ufc.csv')
ufc_df.head(4)

ufc_df.isnull().sum()

ufc_df[ufc_df.isnull().any(axis=1)]

ufc_df.dropna(inplace=True)

ufc_df.duplicated().sum()

ufc_df.info()

numeric_columns = [
    'Fighter_1_KD', 'Fighter_2_KD',
    'Fighter_1_STR', 'Fighter_2_STR',
    'Fighter_1_TD', 'Fighter_2_TD',
    'Fighter_1_SUB', 'Fighter_2_SUB'
]

ufc_df[numeric_columns] = ufc_df[numeric_columns].apply(pd.to_numeric)

ufc_df['Time'] = pd.to_datetime(ufc_df['Time'], format='%M:%S').dt.time
ufc_df['Date'] = pd.to_datetime(ufc_df['Date'], format='%d-%b-%y').dt.date

#done with cleaning

ufc_df.shape

ufc_df.info()

ufc_df.describe()

def describing(df):
    null_column = df.columns[df.isna().any()].tolist()

    missng_values = pd.DataFrame(df[null_column].isna().sum(), columns=['Number_missing'])

    desc = pd.DataFrame(index = list(df))
    desc['count'] = df.count()
    desc['nunique'] = df.nunique()
    desc['%unique'] = desc['nunique'] / len(df) * 100
    desc['null'] = df.isnull().sum()
    desc['Percentage_missing']=np.round(100 * missng_values['Number_missing'] / len(df), 2)
    desc['type'] = ufc_df.dtypes
    desc = pd.concat([desc, df.describe().T.drop('count', axis = 1)], axis = 1)
    return desc

describing(ufc_df)

ufc_df.head()

#now to visualization
#dist of data

import matplotlib.pyplot as plt
import seaborn as sns

# Now, you can use plt and sns for plotting
plt.figure(figsize=(20, 6))
sns.histplot(ufc_df, x='Fighter_1_KD', kde=True, label='Fighter_1_KD', bins=20)
sns.histplot(ufc_df, x='Fighter_2_KD', kde=True, label='Fighter_2_KD', bins=20)

plt.title('Distribution of Knockdowns Columns')
plt.xlabel('Value')
plt.ylabel('Frequency')
plt.legend()
plt.show()

plt.figure(figsize=(20, 6))
sns.histplot(ufc_df, x='Fighter_1_STR', kde=True, label='Fighter_1_STR', bins=20)
sns.histplot(ufc_df, x='Fighter_2_STR', kde=True, label='Fighter_2_STR', bins=20)

plt.title('Distribution of Significant strikes landed Columns')
plt.xlabel('Value')
plt.ylabel('Frequency')
plt.legend()
plt.show()

plt.figure(figsize=(20, 6))
sns.histplot(ufc_df, x='Fighter_1_TD', kde=True, label='Fighter_1_TD', bins=20)
sns.histplot(ufc_df, x='Fighter_2_TD', kde=True, label='Fighter_2_TD', bins=20)

plt.title('Distribution of Takedowns Columns')
plt.xlabel('Value')
plt.ylabel('Frequency')
plt.legend()
plt.show()

plt.figure(figsize=(20, 6))
sns.histplot(ufc_df, x='Round', kde=True, label='Round', bins=20)

plt.title('Distribution of Round Column')
plt.xlabel('Value')
plt.ylabel('Frequency')
plt.legend()
plt.show()

methods = ufc_df['Method']

plt.figure(figsize=(20, 6))
methods.value_counts().plot(kind='bar', color=['orange', 'green', 'blue', 'red'])
plt.title('Distribution of Fight Outcomes')
plt.xlabel('Outcome Method')
plt.ylabel('Number of Fights')
plt.show()

#Identify fighters with exceptional performance in specific areas.

weight_class_column = 'Weight_Class'
outcome_column = 'Method'

weight_class_outcomes = ufc_df.groupby([weight_class_column, outcome_column]).size().unstack(fill_value=0)

plt.figure(figsize=(20, 6))
weight_class_outcomes.plot(kind='bar', stacked=True, cmap='viridis')
plt.title('Outcomes Across Different Weight Classes')
plt.xlabel('Weight Class')
plt.ylabel('Number of Fights')
plt.legend(title='Outcome', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

plt.figure(figsize=(20, 6))
sns.boxplot(data=ufc_df[numeric_columns])
plt.title('Boxplot for Numerical Columns')
plt.show()

plt.figure(figsize=(20, 6))
sns.scatterplot(x=ufc_df['Fighter_1_STR'], y=ufc_df['Fighter_2_STR'], color='blue')
plt.title('Scatter Plot of Fighter_1_STR vs Fighter_2_STR')
plt.xlabel('Fighter_1_STR')
plt.ylabel('Fighter_2_STR')
plt.show()

from scipy.stats.mstats import winsorize

ufc_df['Fighter_1_STR_winsorized'] = winsorize(ufc_df['Fighter_1_STR'], limits=[0.05, 0.05])
ufc_df['Fighter_2_STR_winsorized'] = winsorize(ufc_df['Fighter_2_STR'], limits=[0.05, 0.05])

plt.figure(figsize=(20, 6))
sns.boxplot(data=ufc_df[['Fighter_1_STR_winsorized', 'Fighter_1_STR']])
plt.title('Boxplot After Handling Outliers')
plt.show()

plt.figure(figsize=(20, 6))
sns.boxplot(data=ufc_df[['Fighter_2_STR_winsorized', 'Fighter_2_STR']])
plt.title('Boxplot After Handling Outliers')
plt.show()

weight_class_distribution = ufc_df['Weight_Class'].value_counts()
weight_class_distribution.plot(kind='bar', color='orange', figsize=(20, 6))
plt.title('Distribution of Fights Across Weight Classes')
plt.xlabel('Weight Class')
plt.ylabel('Number of Fights')
plt.xticks(rotation=45, ha='right')
plt.show()

def analyze_winner_statistics(ufc_df):
    winners = ufc_df['Winner']

    winner_counts = winners.value_counts()

    win_methods = ufc_df.loc[ufc_df['Winner'] == winners.mode()[0]]['Method'].value_counts()
    win_rounds = ufc_df.loc[ufc_df['Winner'] == winners.mode()[0]]['Round'].value_counts()

    win_methods.plot(kind='bar', color='green', figsize=(20, 6))
    plt.title('Most Common Win Methods for Winners')
    plt.xlabel('Win Method')
    plt.ylabel('Number of Wins')
    plt.xticks(rotation=45, ha='right')
    plt.show()

    win_rounds.plot(kind='bar', color='orange', figsize=(20, 6))
    plt.title('Most Common Winning Rounds for Winners')
    plt.xlabel('Winning Round')
    plt.ylabel('Number of Wins')
    plt.xticks(rotation=0)
    plt.show()

analyze_winner_statistics(ufc_df)

import pandas as pd

# Path to the Excel file
file_path = '/UFC DATA UPDATED.xlsx'

# Read the Excel file
df_fight_night = pd.read_excel(file_path)

# Display the first 5 rows of the DataFrame
df_fight_night.head(5)



#SMOTE

import pandas as pd
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from imblearn.over_sampling import SMOTE
import pickle
import seaborn as sns
import matplotlib.pyplot as plt

# Load the dataset
df = pd.read_excel('/content/UFC DATA UPDATED.xlsx')

# Compute differences in fight stats as features
df['Diff_SS'] = df.iloc[:, 0] - df.iloc[:, 7]
df['Diff_KD'] = df.iloc[:, 1] - df.iloc[:, 8]
df['Diff_TD'] = df.iloc[:, 2] - df.iloc[:, 9]
df['Diff_CTRL'] = df.iloc[:, 3] - df.iloc[:, 10]
features = ['Diff_SS', 'Diff_KD', 'Diff_TD', 'Diff_CTRL']

# Encode scores for all judges
encoder = LabelEncoder()
for col in ['Score_Fighter_A1', 'Score_Fighter_A2', 'Score_Fighter_A3', 'Score_Fighter_B1', 'Score_Fighter_B2', 'Score_Fighter_B3']:
    df[col + '_encoded'] = encoder.fit_transform(df[col].astype(str))

# Combine encoded scores into a single target variable
df['Combined_Scores'] = df['Score_Fighter_A1_encoded'] + df['Score_Fighter_A2_encoded'] + df['Score_Fighter_A3_encoded'] + df['Score_Fighter_B1_encoded'] + df['Score_Fighter_B2_encoded'] + df['Score_Fighter_B3_encoded']

# Prepare features and labels
X = df[features]
y = df['Combined_Scores']

# Split the dataset
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Oversampling using SMOTE
from imblearn.over_sampling import SMOTE

# Check minimum class size
min_class_size = y_train.value_counts().min()
k_neighbors = min(5, min_class_size - 1)  # Ensure k_neighbors is less than the smallest class size

if k_neighbors > 0:
    smote = SMOTE(random_state=42, k_neighbors=k_neighbors)
    X_train_smote, y_train_smote = smote.fit_resample(X_train, y_train)
else:
    X_train_smote, y_train_smote = X_train, y_train
    print("Not enough samples in at least one class to perform SMOTE. Proceeding with original data.")

# RandomForest with GridSearch
param_grid = {
    'n_estimators': [50, 100, 200],
    'max_depth': [None, 10, 20, 30],
    'min_samples_split': [2, 5, 10],
    'min_samples_leaf': [1, 2, 4]
}
rf = RandomForestClassifier(random_state=42)
grid_search = GridSearchCV(rf, param_grid, cv=3, n_jobs=-1, verbose=2)
grid_search.fit(X_train_smote, y_train_smote)
best_params = grid_search.best_params_

# Train the final model
rf_best = RandomForestClassifier(**best_params)
rf_best.fit(X_train_smote, y_train_smote)

# Save the model and encoder
with open('rf_best_model_retrained.pkl', 'wb') as f:
    pickle.dump(rf_best, f)
with open('encoder_retrained.pkl', 'wb') as f:
    pickle.dump(encoder, f)

# Predict scores on the test set
predictions = rf_best.predict(X_test)

# Evaluate the model
accuracy = accuracy_score(y_test, predictions)
print("Test Accuracy: ", accuracy)

# More detailed performance evaluation
print("Classification Report:")
print(classification_report(y_test, predictions))

# Confusion matrix
cm = confusion_matrix(y_test, predictions)
plt.figure(figsize=(10, 7))
sns.heatmap(cm, annot=True, fmt="d")
plt.title('Confusion Matrix')
plt.ylabel('Actual Label')
plt.xlabel('Predicted Label')
plt.show()

import pandas as pd
from sklearn.preprocessing import LabelEncoder

# Load dataset
df = pd.read_excel('/content/UFC DATA UPDATED.xlsx')

# Combine encoded scores into a single target variable
encoder = LabelEncoder()
for col in ['Score_Fighter_A1', 'Score_Fighter_A2', 'Score_Fighter_A3', 'Score_Fighter_B1', 'Score_Fighter_B2', 'Score_Fighter_B3']:
    df[col + '_encoded'] = encoder.fit_transform(df[col].astype(str))
df['Combined_Scores'] = df['Score_Fighter_A1_encoded'] + df['Score_Fighter_A2_encoded'] + df['Score_Fighter_A3_encoded'] + df['Score_Fighter_B1_encoded'] + df['Score_Fighter_B2_encoded'] + df['Score_Fighter_B3_encoded']

# Print the class distribution
class_distribution = df['Combined_Scores'].value_counts()
print("Class Distribution:\n", class_distribution)

# Print total number of rows in the dataset
total_rows = df.shape[0]
print("TOTAL NUMBER OF ROUNDS IN DATASET:", total_rows)